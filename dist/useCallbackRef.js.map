{"version":3,"sources":["useCallbackRef.js"],"names":["useCallbackRef","callbackRef","setCallbackRef","nextCallback","current"],"mappings":";;;;;;;AAAA;;AAsBA,IAAMA,cAAc,GAAG,SAAjBA,cAAiB,GAAM;AAC3B,MAAMC,WAAW,GAAG,oBAApB;AAEA,MAAMC,cAAc,GAAG,wBAAY,UAACC,YAAD,EAAkB;AACnD,QAAIA,YAAY,KAAKF,WAAW,CAACG,OAA7B,IAAwC,OAAOD,YAAP,KAAwB,UAApE,EAAgF;AAC9EF,MAAAA,WAAW,CAACG,OAAZ,GAAsBD,YAAtB;AACD;AACF,GAJsB,EAIpB,CAACF,WAAD,CAJoB,CAAvB;AAMA,SAAO,CAACA,WAAD,EAAcC,cAAd,CAAP;AACD,CAVD;;eAYeF,c","sourcesContent":["import { useCallback, useRef } from 'react';\n\n/**\n * Creates a callback reference that will live trough the component lifecycle until changed.\n * Returns the callback ref and a setter to change its value, as per the React hooks convention.\n * The setter also makes sure that the given callback is indeed a function.\n * If not the callback ref won't change.\n *\n * Usage:\n *\n * ```jsx harmony\n * const MyComponent = () => {\n *   const [ callbackRef, setCallbackRef ] = useCallbackRef();\n *\n *   setCallbackRef(() => console.log('A persistent callback'));\n *\n *   useEffect(callbackRef.current, []);\n *\n *   return (<div />)\n * }\n * ```\n */\nconst useCallbackRef = () => {\n  const callbackRef = useRef();\n\n  const setCallbackRef = useCallback((nextCallback) => {\n    if (nextCallback !== callbackRef.current && typeof nextCallback === 'function') {\n      callbackRef.current = nextCallback;\n    }\n  }, [callbackRef]);\n\n  return [callbackRef, setCallbackRef];\n};\n\nexport default useCallbackRef;\n"],"file":"useCallbackRef.js"}