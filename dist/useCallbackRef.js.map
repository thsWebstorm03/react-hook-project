{"version":3,"sources":["useCallbackRef.js"],"names":["useCallbackRef","initialValue","callbackRef","current","setCallbackRef","nextCallback","invokeImmediately"],"mappings":";;;;;;;AAAA;;AAaA,IAAMA,cAAc,GAAG,SAAjBA,cAAiB,CAACC,YAAD,EAAkB;AACvC,MAAMC,WAAW,GAAG,mBAAOD,YAAP,CAApB;AACAC,EAAAA,WAAW,CAACC,OAAZ,GAAsBF,YAAtB;AAEA,MAAMG,cAAc,GAAG,wBAAY,UAACC,YAAD,EAA6C;AAAA,QAA9BC,iBAA8B,uEAAV,KAAU;;AAC9E,QAAID,YAAY,KAAKH,WAAW,CAACC,OAA7B,IAAwC,OAAOE,YAAP,KAAwB,UAApE,EAAgF;AAC9EH,MAAAA,WAAW,CAACC,OAAZ,GAAsBE,YAAtB;AACA,UAAIC,iBAAJ,EAAuBJ,WAAW,CAACC,OAAZ;AACxB;AACF,GALsB,CAAvB;AAOA,SAAO,CAACD,WAAD,EAAcE,cAAd,CAAP;AACD,CAZD;;eAceJ,c","sourcesContent":["import { useCallback, useRef } from 'react';\n\n/**\n * Returns an array where the first item is the [ref](https://reactjs.org/docs/hooks-reference.html#useref) to a\n * callback function and the second one is setter for that function.<br /><br />\n *\n * Although it looks quite similar to a [useState](https://reactjs.org/docs/hooks-reference.html#usestate), in this\n * case the setter just makes sure the given callback is indeed a new function.<br /><br />\n * **Setting a callback ref does not imply your component to re-render.**<br /><br />\n *\n * `useCallbackRef` is useful when abstracting other custom hooks to possibly implement callback setters.\n *\n */\nconst useCallbackRef = (initialValue) => {\n  const callbackRef = useRef(initialValue);\n  callbackRef.current = initialValue;\n\n  const setCallbackRef = useCallback((nextCallback, invokeImmediately = false) => {\n    if (nextCallback !== callbackRef.current && typeof nextCallback === 'function') {\n      callbackRef.current = nextCallback;\n      if (invokeImmediately) callbackRef.current();\n    }\n  });\n\n  return [callbackRef, setCallbackRef];\n};\n\nexport default useCallbackRef;\n"],"file":"useCallbackRef.js"}