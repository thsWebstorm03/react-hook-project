{"version":3,"sources":["useCallbackRef.js"],"names":["useCallbackRef","callbackRef","setCallbackRef","nextCallback","current"],"mappings":";;;;;;;AAAA;;AAsCA,IAAMA,cAAc,GAAG,SAAjBA,cAAiB,GAAM;AAC3B,MAAMC,WAAW,GAAG,oBAApB;AAEA,MAAMC,cAAc,GAAG,wBAAY,UAACC,YAAD,EAAkB;AACnD,QAAIA,YAAY,KAAKF,WAAW,CAACG,OAA7B,IAAwC,OAAOD,YAAP,KAAwB,UAApE,EAAgF;AAC9EF,MAAAA,WAAW,CAACG,OAAZ,GAAsBD,YAAtB;AACD;AACF,GAJsB,CAAvB;AAMA,SAAO,CAACF,WAAD,EAAcC,cAAd,CAAP;AACD,CAVD;;eAYeF,c","sourcesContent":["import { useCallback, useRef } from 'react';\n\n/**\n * Creates a callback reference that will live trough the component lifecycle.<br />\n * It returns the callback ref and a setter to change its value.<br />\n * The setter also makes sure the given callback is indeed a function, if not the callback ref won't change.<br />\n * Callback ref are quite useful when abstracting other custom hooks.\n\n * ### Usage in a custom hook:\n *\n * ```jsx harmony\n * const useSomething = () => {\n *   const [ callbackRef, setSomething ] = useCallbackRef();\n *\n *   useEffect(() => {\n *     if (callbackRef.current) {\n *       callbackRef.current();\n *     }\n *   }, [callbackRef]);\n *\n *   return setSomething;\n * }\n * ```\n *\n * ### Usage in a component:\n *\n * ```jsx harmony\n * const MyComponent = () => {\n *   const [ callbackRef, setCallbackRef ] = useCallbackRef();\n *\n *   setCallbackRef(() => console.log('A persistent callback'));\n *\n *   useEffect(callbackRef.current, []);\n *\n *   return (<div />)\n * }\n * ```\n */\nconst useCallbackRef = () => {\n  const callbackRef = useRef();\n\n  const setCallbackRef = useCallback((nextCallback) => {\n    if (nextCallback !== callbackRef.current && typeof nextCallback === 'function') {\n      callbackRef.current = nextCallback;\n    }\n  });\n\n  return [callbackRef, setCallbackRef];\n};\n\nexport default useCallbackRef;\n"],"file":"useCallbackRef.js"}